<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Sub-Grid Pixel Sorcery</title>
  <style>
    html,body{margin:0;height:100%;background:#000;display:flex;align-items:center;justify-content:center;}
    canvas{image-rendering:pixelated;}
    #save {position:fixed;top:12px;right:12px;padding:6px 10px;font:14px monospace;}
  </style>
</head>
<body>
<button id="save">⤓ save</button>

<!-- p5.js CDN -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.3/p5.min.js"></script>
<script>
/* ---------- parameters you can tweak ------------------ */
const GRID_SIZE   = 8;            // base subdivision
const SORT_CHANCE = 0.6;          // per-row pixel-sort probability
const NOISE_MAG   = 8;            // displacement strength
const DITHER_PROB = 0.15;         // 15 % Bayer chance
const SWIRL_COUNT = 200;          // number of swirling paths
const SWIRL_STEPS = 80;           // segment count per path
/* ------------------------------------------------------ */

function setup() {
  createCanvas(windowWidth, windowHeight);
  noLoop();                       // draw() runs once
}

function draw() {
  background(0);
  const cell = width / GRID_SIZE;
  
  // 1 · draw colourful grid
  for (let y = 0; y < GRID_SIZE; y++) {
    for (let x = 0; x < GRID_SIZE; x++) {
      fill(random(360), 80, 100);
      rect(x*cell, y*cell, cell, cell);
    }
  }
  // 2 · pixel-sort some rows
  loadPixels();
  for (let y = 0; y < height; y++) {
    if (random() > SORT_CHANCE) continue;
    const row = [];
    for (let x = 0; x < width; x++) {
      const idx = 4*(y*width + x);
      row.push( pixels.slice(idx, idx+4) );          // RGBA chunk
    }
    row.sort((a,b)=>brightness(color(...a)) - brightness(color(...b)));
    for (let x = 0; x < width; x++) {
      const idx = 4*(y*width + x);
      pixels.set(row[x], idx);
    }
  }
  // 3 · noise-based displacement
  const copy = pixels.slice();                      // snapshot before warp
  for (let y = 0; y < height; y++) {
    for (let x = 0; x < width; x++) {
      const dx = floor( noise(x*0.01, y*0.01)*NOISE_MAG );
      const dy = floor( noise(y*0.01, x*0.01)*NOISE_MAG );
      const sx = constrain(x+dx,0,width-1);
      const sy = constrain(y+dy,0,height-1);
      const from = 4*(sy*width + sx);
      const to   = 4*(y*width  + x);
      pixels[to]=copy[from]; pixels[to+1]=copy[from+1];
      pixels[to+2]=copy[from+2]; pixels[to+3]=255;
    }
  }
  updatePixels();

  // 4 · optional Bayer dithering
  if (random() < DITHER_PROB) bayerDither();

  // 5 · swirling line overlays
  swirlArt();
}

/* --- tiny 4x4 Bayer matrix --- */
function bayerDither(){
  loadPixels();
  const M=[0,8,2,10,12,4,14,6,3,11,1,9,15,7,13,5];
  for (let y=0;y<height;y++){
    for (let x=0;x<width;x++){
      const idx=4*(y*width+x);
      for (let c=0;c<3;c++){
        const old=pixels[idx+c];
        const thresh = M[ (y&3)*4 + (x&3) ]*16;
        pixels[idx+c]= old<thresh?0:255;
      }
    }
  }
  updatePixels();
}

/* --- swirling noise-based lines --- */
function swirlArt(){
  push();
  colorMode(HSB, 360, 100, 100, 100);
  strokeWeight(2);
  noFill();
  for(let i=0;i<SWIRL_COUNT;i++){
    let x=random(width);
    let y=random(height);
    const baseHue=random(360);
    stroke(baseHue,80,100,50);
    beginShape();
    for(let j=0;j<SWIRL_STEPS;j++){
      vertex(x,y);
      const angle=noise(x*0.005,y*0.005,j*0.05)*TWO_PI*4;
      x+=cos(angle)*2;
      y+=sin(angle)*2;
      if(x<0||x>width||y<0||y>height)break;
    }
    endShape();
  }
  pop();
}

/* --- save PNG --- */
document.getElementById('save').onclick=()=>saveCanvas('grid','png');

function windowResized(){resizeCanvas(windowWidth,windowHeight); redraw();}
</script>
</body>
</html>
