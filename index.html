<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Sub-Grid Pixel Sorcery</title>
  <style>
    html,body{margin:0;height:100%;background:#000;display:flex;align-items:center;justify-content:center;}
    canvas{image-rendering:pixelated;}
    #save {position:fixed;top:12px;right:12px;padding:6px 10px;font:14px monospace;}
    #metrics {position:fixed;bottom:12px;left:12px;padding:6px 10px;font:12px monospace;background:rgba(0,0,0,0.5);color:#fff;}
    #metrics canvas{display:block;margin-top:4px;}
  </style>
</head>
<body>
<button id="save">⤓ save</button>
<div id="metrics"></div>

<!-- p5.js CDN -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.3/p5.min.js"></script>
<script>
/* ---------- parameters you can tweak ------------------ */
const GRID_SIZE   = 8;            // base subdivision
const SORT_CHANCE = 0.6;          // per-row pixel-sort probability
const NOISE_MAG   = 8;            // displacement strength
const DITHER_PROB = 0.15;         // 15 % Bayer chance
/* ------------------------------------------------------ */

let metricsCanvas;

function setup() {
  createCanvas(windowWidth, windowHeight);
  metricsCanvas = createGraphics(256, 100);
  document.getElementById('metrics').appendChild(metricsCanvas.canvas);
  noLoop();                       // draw() runs once
}

function draw() {
  background(0);
  const cell = width / GRID_SIZE;
  
  // 1 · draw colourful grid
  for (let y = 0; y < GRID_SIZE; y++) {
    for (let x = 0; x < GRID_SIZE; x++) {
      fill(random(360), 80, 100);
      rect(x*cell, y*cell, cell, cell);
    }
  }
  // 2 · pixel-sort some rows
  loadPixels();
  for (let y = 0; y < height; y++) {
    if (random() > SORT_CHANCE) continue;
    const row = [];
    for (let x = 0; x < width; x++) {
      const idx = 4*(y*width + x);
      row.push( pixels.slice(idx, idx+4) );          // RGBA chunk
    }
    row.sort((a,b)=>brightness(color(...a)) - brightness(color(...b)));
    for (let x = 0; x < width; x++) {
      const idx = 4*(y*width + x);
      pixels.set(row[x], idx);
    }
  }
  // 3 · noise-based displacement
  const copy = pixels.slice();                      // snapshot before warp
  for (let y = 0; y < height; y++) {
    for (let x = 0; x < width; x++) {
      const dx = floor( noise(x*0.01, y*0.01)*NOISE_MAG );
      const dy = floor( noise(y*0.01, x*0.01)*NOISE_MAG );
      const sx = constrain(x+dx,0,width-1);
      const sy = constrain(y+dy,0,height-1);
      const from = 4*(sy*width + sx);
      const to   = 4*(y*width  + x);
      pixels[to]=copy[from]; pixels[to+1]=copy[from+1];
      pixels[to+2]=copy[from+2]; pixels[to+3]=255;
    }
  }
  updatePixels();

  // 4 · optional Bayer dithering
  if (random() < DITHER_PROB) bayerDither();
  displayMetrics();
}

/* --- tiny 4x4 Bayer matrix --- */
function bayerDither(){
  loadPixels();
  const M=[0,8,2,10,12,4,14,6,3,11,1,9,15,7,13,5];
  for (let y=0;y<height;y++){
    for (let x=0;x<width;x++){
      const idx=4*(y*width+x);
      for (let c=0;c<3;c++){
        const old=pixels[idx+c];
        const thresh = M[ (y&3)*4 + (x&3) ]*16;
        pixels[idx+c]= old<thresh?0:255;
      }
    }
  }
  updatePixels();
}

function displayMetrics(){
  loadPixels();
  const bins=new Array(16).fill(0);
  let sum=0,maxB=0;
  for(let i=0;i<pixels.length;i+=4){
    const r=pixels[i],g=pixels[i+1],b=pixels[i+2];
    const br=0.299*r+0.587*g+0.114*b;
    sum+=br;
    if(br>maxB) maxB=br;
    bins[Math.floor(br/16)]++;
  }
  const avg=sum/(width*height);
  const ctx=metricsCanvas;
  ctx.clear();
  ctx.background(0,200);
  const h=ctx.height-20;
  const maxCount=Math.max(...bins);
  ctx.stroke(255);
  for(let i=0;i<bins.length;i++){
    const bar=bins[i]/maxCount*h;
    ctx.line(i*16+8,ctx.height-10,i*16+8,ctx.height-10-bar);
  }
  const div=document.getElementById('metrics');
  div.firstChild&&div.firstChild.remove();
  div.prepend(document.createTextNode(`avg ${avg.toFixed(1)} | max ${maxB.toFixed(1)}`));
}

/* --- save PNG --- */
document.getElementById('save').onclick=()=>saveCanvas('grid','png');

function windowResized(){resizeCanvas(windowWidth,windowHeight); redraw();}
</script>
</body>
</html>
