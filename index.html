<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Sub-Grid Pixel Sorcery</title>
  <style>
    html,body{margin:0;height:100%;background:#000;display:flex;align-items:center;justify-content:center;}
    canvas{image-rendering:pixelated;}
    #save {position:fixed;top:12px;right:12px;padding:6px 10px;font:14px monospace;}
  </style>
</head>
<body>
<button id="save">⤓ save</button>
<div id="fps"></div>

<!-- p5.js CDN -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.3/p5.min.js"></script>
<script>
/* ---------- parameters you can tweak ------------------ */
const GRID_SIZE   = 8;            // base subdivision
const SORT_CHANCE = 0.6;          // per-row pixel-sort probability
const NOISE_MAG   = 8;            // displacement strength
const DITHER_PROB = 0.15;         // 15 % Bayer chance
/* ------------------------------------------------------ */

let gfx;
let fpsDiv;
let frameTimes = [];
let bayerLoaded = false;

function setup() {
  createCanvas(windowWidth, windowHeight);
  gfx = createGraphics(width, height);
  colorMode(HSB, 360, 100, 100, 255);
  gfx.colorMode(HSB, 360, 100, 100, 255);
  fpsDiv = select('#fps');
}

async function draw() {
  const start = millis();
  gfx.background(0);
  const cell = gfx.width / GRID_SIZE;

  // 1 · draw colourful grid
  for (let y = 0; y < GRID_SIZE; y++) {
    for (let x = 0; x < GRID_SIZE; x++) {
      gfx.fill(random(360), 80, 100);
      gfx.rect(x*cell, y*cell, cell, cell);
    }
  }
  // 2 · pixel-sort some rows
  gfx.loadPixels();
  for (let y = 0; y < gfx.height; y++) {
    if (random() > SORT_CHANCE) continue;
    const row = [];
    for (let x = 0; x < gfx.width; x++) {
      const idx = 4*(y*gfx.width + x);
      row.push( gfx.pixels.slice(idx, idx+4) );          // RGBA chunk
    }
    row.sort((a,b)=>brightness(color(...a)) - brightness(color(...b)));
    for (let x = 0; x < gfx.width; x++) {
      const idx = 4*(y*gfx.width + x);
      gfx.pixels.set(row[x], idx);
    }
  }
  // 3 · noise-based displacement
  const copy = gfx.pixels.slice();                      // snapshot before warp
  for (let y = 0; y < gfx.height; y++) {
    for (let x = 0; x < gfx.width; x++) {
      const dx = floor( noise(x*0.01, y*0.01)*NOISE_MAG );
      const dy = floor( noise(y*0.01, x*0.01)*NOISE_MAG );
      const sx = constrain(x+dx,0,gfx.width-1);
      const sy = constrain(y+dy,0,gfx.height-1);
      const from = 4*(sy*gfx.width + sx);
      const to   = 4*(y*gfx.width  + x);
      gfx.pixels[to]=copy[from]; gfx.pixels[to+1]=copy[from+1];
      gfx.pixels[to+2]=copy[from+2]; gfx.pixels[to+3]=255;
    }
  }
  gfx.updatePixels();

  // 4 · optional Bayer dithering loaded on demand
  if (random() < DITHER_PROB) {
    await loadBayer();
    bayerDither(gfx);
  }

  background(0);
  image(gfx, 0, 0, width, height);

  frameTimes.push(millis() - start);
  if (frameTimes.length > 60) frameTimes.shift();
  fpsDiv.html(nf(frameRate(), 2, 2) + ' fps');
}

function loadBayer(){
  return new Promise((resolve)=>{
    if(bayerLoaded){ resolve(); return; }
    const s=document.createElement('script');
    s.src='bayer.js';
    s.onload=()=>{bayerLoaded=true; resolve();};
    document.body.appendChild(s);
  });
}

/* --- save PNG --- */
document.getElementById('save').onclick=()=>saveCanvas('grid','png');

function windowResized(){
  resizeCanvas(windowWidth,windowHeight);
  gfx = createGraphics(width, height);
}
</script>
</body>
</html>
